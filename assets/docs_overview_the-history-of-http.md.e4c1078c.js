import{_ as n,E as e,o as t,c as o,J as l,w as p,U as s,a as r}from"./chunks/framework.62682723.js";const i="/HTTP-Explanation/assets/proposal.b2a8ab1f.gif",u=JSON.parse('{"title":"HTTP的历史","description":"","frontmatter":{},"headers":[],"relativePath":"docs/overview/the-history-of-http.md","filePath":"docs/overview/the-history-of-http.md","lastUpdated":1689781626000}'),c={name:"docs/overview/the-history-of-http.md"},T=s('<h1 id="http的历史" tabindex="-1">HTTP的历史 <a class="header-anchor" href="#http的历史" aria-label="Permalink to &quot;HTTP的历史&quot;">​</a></h1><p><strong>超文本传输协议</strong>（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol，缩写：<strong>HTTP</strong>）是<a href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91" target="_blank" rel="noreferrer">万维网</a>（World Wide Web）的基础协议。自<a href="https://zh.wikipedia.org/wiki/%E6%8F%90%E5%A7%86%C2%B7%E6%9F%8F%E5%85%A7%E8%8C%B2-%E6%9D%8E" target="_blank" rel="noreferrer">蒂姆·伯纳斯-李 </a>（Tim BernersLee）博士和他的团队在 1989-1991 年间创造出它以来，HTTP 已经发生了太多的变化，在保持协议简单性的同时，不断扩展其灵活性。如今，HTTP 已经从一个只在实验室之间交换文档的早期协议进化到了可以传输图片，高分辨率视频和 3D 效果的现代复杂互联网协议。</p><h2 id="http的诞生" tabindex="-1">HTTP的诞生 <a class="header-anchor" href="#http的诞生" aria-label="Permalink to &quot;HTTP的诞生&quot;">​</a></h2><p>1989 年 3 月<a href="https://zh.wikipedia.org/wiki/%E6%AD%90%E6%B4%B2%E6%A0%B8%E5%AD%90%E7%A0%94%E7%A9%B6%E7%B5%84%E7%B9%94" target="_blank" rel="noreferrer">欧洲核子研究组织</a>（CERN）的<a href="https://zh.wikipedia.org/wiki/%E6%8F%90%E5%A7%86%C2%B7%E6%9F%8F%E5%85%A7%E8%8C%B2-%E6%9D%8E" target="_blank" rel="noreferrer">蒂姆·伯纳斯-李 </a>（Tim BernersLee）博士提出了一种能让远隔两地的研究者们共享知识的设想。 最初设想的基本理念是：借助多文档之间相互关联形成的超文本（HyperText），连成可相互参阅的 WWW（World Wide Web，万维网）。</p><p><img src="'+i+'" alt="proposal"></p>',5),h=s(`<p>到 1990 年 10 月，Tim 编写了三项基本技术来实现设想，这些技术仍然是当今网络的基础（您可能已经在网络浏览器的某些部分上看到过这些技术）：</p><ul><li>HTML（HyperText Markup Language）：超文本标记语言，作为编写文档的语言。</li><li>HTTP（HyperText Transfer Protocol）：超文本传输协议，作为传递文档的协议。</li><li>URL（Uniform Resource Locator）：统一资源标识符，一种唯一的“地址”，用于标识文档在网络上的位置。</li></ul><p>此外 Tim 还编写了第一个网页编辑器/浏览器（“WorldWideWeb.app”）和第一个 Web 服务器（“httpd”）。至此 Tim 初步完成了他的设想的所有技术实现，且第一批服务器已经在 1991 年初在 CERN 以外的地方运行了，1991 年 8 月 16 日，Tim Berners-Lee 在公开的超文本新闻组上<a href="https://www.w3.org/People/Berners-Lee/1991/08/art-6484.txt" target="_blank" rel="noreferrer">发表</a>的文章被视为是万维网公共项目的开始。</p><p>对于HTTP而言， 在应用的早期阶段它是非常简单的，后来它也被称为 HTTP/0.9，有时也叫做单行hang（one-line）协议。</p><h2 id="http-0-9——单行协议-1991" tabindex="-1">HTTP/0.9——单行协议(1991) <a class="header-anchor" href="#http-0-9——单行协议-1991" aria-label="Permalink to &quot;HTTP/0.9——单行协议(1991)&quot;">​</a></h2><p>最初版本的 HTTP 协议并没有版本号，后来它的版本号被定位在 0.9 以区分后来的版本。<a href="https://www.w3.org/Protocols/HTTP/AsImplemented.html" target="_blank" rel="noreferrer">HTTP/0.9</a>于 1991 年提出。它是有史以来最简单的协议；它的请求由单行指令构成（因此也称为单行协议），以唯一可用方法 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" target="_blank" rel="noreferrer"><code>GET</code></a> 开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。</p><div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">GET</span><span style="color:#A6ACCD;"> /index.html</span></span></code></pre></div><p>响应也极其简单的：只包含HTML文档本身。</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">HTML</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">这是一个非常简单的 HTML 页面</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">HTML</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>跟后来的版本不同，HTTP/0.9 的响应内容并不包含 HTTP 头。这意味着只有 HTML 文件可以传送，无法传输其他类型的文件。也没有状态码或错误代码。一旦出现问题，一个特殊的包含问题描述信息的 HTML 文件将被发回，供人们查看。</p><h3 id="特性" tabindex="-1">特性 <a class="header-anchor" href="#特性" aria-label="Permalink to &quot;特性&quot;">​</a></h3><ul><li><p>它是 ASCII 协议，请求/响应都是由ASCII字符组成字符串。</p></li><li><p>它在TCP/IP 链路上运行。</p></li><li><p>请求以回车符 (CRLF) 终止。</p></li><li><p>响应只包含HTML文档。</p></li><li><p>文档传输完成后，TCP连接将终止。</p></li></ul><h3 id="缺陷" tabindex="-1">缺陷 <a class="header-anchor" href="#缺陷" aria-label="Permalink to &quot;缺陷&quot;">​</a></h3><ul><li><strong>只支持GET请求：</strong> HTTP/0.9仅支持GET方法，意味着只能用于获取资源，不能用于其他类型的请求，如POST、PUT、DELETE等。这导致在处理复杂的应用逻辑和实现数据更新等操作时，HTTP/0.9显得非常有限。</li><li><strong>只能传输HTML：</strong> HTTP/0.9的响应只能包含HTML文档，无法处理其他类型的数据，如JSON、XML、图像等。这限制了其在处理现代Web应用程序中的数据传输和交互能力。</li><li><strong>无法进行内容协商：</strong> HTTP/0.9没有头部信息，无法携带元数据，如Content-Type、Content-Length等，这使得它无法识别并正确解析其他响应内容。</li><li><strong>没有状态码或错误代码：</strong> 也是由于HTTP/0.9没有头部信息，无法携带元数据，因此响应成功与失败都是返回HTML文档，这使得浏览器不能知晓请求执行成功或失败，并相应调整行为。</li><li><strong>不支持持久连接：</strong> 在HTTP/0.9中，每次请求都会建立一个新的TCP连接，请求完成后立即关闭连接。这导致在处理大量请求时，频繁地建立和关闭连接会带来较大的开销，影响性能。</li><li><strong>安全性问题：</strong> HTTP/0.9没有提供任何加密和安全机制，所有的数据都是明文传输。这使得数据容易受到窃听和篡改，缺乏对隐私和数据完整性的保护。</li><li><strong>只能传输英文文本数据：</strong> HTTP/0.9默认采用的字符集是ASCII字符集，这意味着HTTP只能传输英文文本数据，无法支持其他语言的文本数据，比如包含非英文字符的文本（如中文、日文、俄文等）。</li></ul><p>正如你们所看到的，HTTP/0.9仅适用于简单的、仅需要获取HTML文档的场景。新兴 Web 所需功能及其在公共 Web 上的用例不断增长，很快就强化了 HTTP 0.9 的许多缺陷：我们需要一个协议，该协议不仅可以服务于超文本文档，还可以提供有关请求和响应的更丰富的元数据。</p><p>很快，HTTP 的下一个版本（即 HTTP/1.0）被推出，它解决了HTTP/0.9的缺陷，并提供更多强大的功能和性能优化。</p><h2 id="http-1-0——构建可扩展性-1996" tabindex="-1">HTTP/1.0——构建可扩展性(1996) <a class="header-anchor" href="#http-1-0——构建可扩展性-1996" aria-label="Permalink to &quot;HTTP/1.0——构建可扩展性(1996)&quot;">​</a></h2><p>1996 年 5 月，HTTP 工作组 (HTTP-WG) 发布了 <a href="https://datatracker.ietf.org/doc/html/rfc1945" target="_blank" rel="noreferrer">RFC 1945</a>，文档 <a href="https://datatracker.ietf.org/doc/html/rfc1945" target="_blank" rel="noreferrer">RFC 1945</a> 定义了 HTTP/1.0，但它是狭义的，并不是官方标准。</p><p>HTTP/1.0 通过定义了HTTP请求/响应的结构，加入许多头部信息，现在可以处理其他响应格式，即图像、视频文件、纯文本或任何其他内容类型。它添加了更多方法（即 POST 和 HEAD）、添加了状态代码来标识响应、引入了字符集、类型、授权、缓存、内容编码等内容。</p><p>以下为 HTTP/1.0 的请求示例：</p><div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">GET</span><span style="color:#A6ACCD;"> / </span><span style="color:#F78C6C;">HTTP</span><span style="color:#A6ACCD;">/</span><span style="color:#F78C6C;">1.0</span></span>
<span class="line"><span style="color:#F07178;">Host</span><span style="color:#F78C6C;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">cs.fyi</span></span>
<span class="line"><span style="color:#F07178;">User-Agent</span><span style="color:#F78C6C;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span></span>
<span class="line"><span style="color:#F07178;">Accept</span><span style="color:#F78C6C;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">*/*</span></span></code></pre></div><p>以下为 HTTP/1.0 的响应示例：</p><div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">HTTP/1.0 200 OK </span></span>
<span class="line"><span style="color:#F07178;">Content-Type</span><span style="color:#F78C6C;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">text/plain</span></span>
<span class="line"><span style="color:#F07178;">Content-Length</span><span style="color:#F78C6C;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">137582</span></span>
<span class="line"><span style="color:#F07178;">Expires</span><span style="color:#F78C6C;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">Thu, 05 Dec 1997 16:00:00 GMT</span></span>
<span class="line"><span style="color:#F07178;">Last-Modified</span><span style="color:#F78C6C;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">Wed, 5 August 1996 15:55:28 GMT</span></span>
<span class="line"><span style="color:#F07178;">Server</span><span style="color:#F78C6C;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">Apache 0.84</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">(response body)</span></span>
<span class="line"><span style="color:#A6ACCD;">(connection closed)</span></span></code></pre></div><p>HTTP/1.0 的请求与响应现在看起来也是非常熟悉的，因为它首次定义了请求/响应的格式我们沿用至今，并且由于加入头信息，使得内容协商变得容易起来，这也极大的丰富了它的扩展性，虽然请求和响应标头仍保留为 ASCII 编码，但响应正文可以是任何类型，即图像、视频、HTML、纯文本或任何其他内容类型。因此，现在服务器不仅仅只能向客户端发送HTML文档，还可以发送其他任何内容类型；推出后不久，HTTP 中的“超文本”一词就变得用词不当。HMTP 或超媒体传输协议可能更有意义，但我想，我们终生都坚持这个名字。</p><div class="tip custom-block"><p class="custom-block-title">请求与响应头仍是ASCII编码，那么其中的中文是如何处理的呢？</p><p>我们都知道ASCII编码仅表示了英文小大写、数字以及一些标点符号，对于其他国家的语言是并不支持的，那么请求头中的其他国家的语言的信息如何处理呢？</p><blockquote><p>我尝试使用浏览器访问以中文命名的HTML，URL：<a href="https://wangjunliang.com/%E6%88%91%E6%83%B3%E7%9C%8B%E7%9C%8B.html" target="_blank" rel="noreferrer">wangjunliang.com/我想看看.html</a></p></blockquote><div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F07178;">请求网址</span><span style="color:#F78C6C;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">https://www.wangjunliang.com/%E6%88%91%E6%83%B3%E7%9C%8B%E7%9C%8B.html</span></span>
<span class="line"><span style="color:#F07178;">请求方法</span><span style="color:#F78C6C;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">GET</span></span>
<span class="line"><span style="color:#F07178;">状态代码</span><span style="color:#F78C6C;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">200</span></span>
<span class="line"><span style="color:#F07178;">远程地址</span><span style="color:#F78C6C;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">127.0.0.1:7890</span></span>
<span class="line"><span style="color:#F07178;">引荐来源网址政策</span><span style="color:#F78C6C;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">strict-origin-when-cross-origin</span></span></code></pre></div><p>惊奇的发现在请求头中<code>我想看看</code>转换为了<code>%E6%88%91%E6%83%B3%E7%9C%8B%E7%9C%8B</code>，这就是传说中的URL编码。</p><p><strong>URL编码：</strong> URL 编码是一种将特殊字符和非 ASCII 字符转换为 ASCII 字符的方法，使它们能够在 HTTP 请求的 URL 中进行传输。具体而言，URL 编码使用 &quot;%&quot; 符号后跟两个十六进制数字来表示一个字符。例如，中文字符 &quot;中&quot; 的 URL 编码表示为 &quot;%E4%B8%AD&quot;。这个编码表示了字符 &quot;中&quot; 在 ASCII 字符集中的十六进制表示。当 HTTP/1.0 的请求或响应中包含中文字符时，这些字符会被转换成对应的 URL 编码形式。服务器收到 URL 编码后的请求后，会将其还原为原始的中文字符进行处理。需要注意的是，HTTP/1.0 的 URL 编码仅适用于 URL 中的字符编码。</p></div><h3 id="特性-1" tabindex="-1">特性 <a class="header-anchor" href="#特性-1" aria-label="Permalink to &quot;特性&quot;">​</a></h3><ul><li><strong>定义了请求/响应格式：</strong> HTTP/1.0将请求/响应格式划分为了三个部分——起始行、头部信息、消息体，这个格式一直沿用至今。</li><li><strong>加入了状态码和状态描述：</strong> 在响应的起始行中加入了状态代码和状态的描述信息，提供了关于请求处理结果的信息，以便客户端和服务器能够进行适当的处理和决策。</li><li><strong>加入了内容协商：</strong> 虽然在HTTP/1.0中起始行与头部信息都保留为 ASCII 编码，但它通过加入了Content-Type、Content-Length、Transfer-Encoding等头部属性，可以对不同类型的文件在消息体中进行不同的编码。也就是说起始行、头部信息传输仍是ASCII编码，而消息体则会根据头部属性让客户端/服务器进行内容协商，进行不同的编码方式。</li><li><strong>可以传输任何文件：</strong> 由于HTTP/1.0加入了内容协商的机制，使得只要客户端/服务器协商一致，HTTP/1.0就可以传输任何形式的文件。</li><li><strong>新增POST、HEAD请求：</strong> POST请求方法允许客户端向服务器提交数据，而HEAD请求方法允许客户端获取资源的元数据。这些新增的请求方法丰富了HTTP协议的能力，使得客户端和服务器能够进行更多样化的交互和处理。</li><li><strong>不再只是传输英文文本数据：</strong> HTTP/1.0引入字符集（Character Set），解决了其他国家语言文本数据的字符编码问题，并确保文本数据能够以正确的方式被处理和显示。</li><li><strong>初步引入缓存概念：</strong> HTTP/1.0引入了头部字段如Expires和Last-Modified，用于控制缓存的行为，以及头部字段如If-Modified-Since和If-None-Match，用于条件性请求。</li><li><strong>初步引入持久链接：</strong> HTTP/1.0引入一个名为 Connection: keep-alive 的新标头，来保持请求建立起来的TCP连接，以供后续请求继续使用该链接完成请求。</li><li><strong>初步引入代理支持：</strong> HTTP/1.0引入了Proxy-Connection头部字段来指示代理服务器是否应保持持久连接，并引入了Via头部字段，用于标识请求经过的代理服务器链。</li></ul><h3 id="缺陷-1" tabindex="-1">缺陷 <a class="header-anchor" href="#缺陷-1" aria-label="Permalink to &quot;缺陷&quot;">​</a></h3><ul><li><p><strong>持久链接未得到广泛支持，默认仍为短连接：</strong> HTTP/1.0 的尝试通过引入一个名为 Connection: keep-alive 的新标头来克服短连接问题，但它仍然没有得到广泛的支持，问题仍然存在。</p></li><li><p><strong>请求阻塞：</strong> 在HTTP/1.0中，每个请求都需要按照顺序进行，即必须等待前一个请求的响应返回后才能发送下一个请求。如果前一个请求很耗时，会导致后续请求被阻塞，影响并发性能。</p></li><li><p><strong>无状态：</strong> HTTP是一种无状态协议，即服务器不维护有关客户端的信息，当客户端需要记录状态时，必须发送一些记录状态的冗余数据，从而导致带宽使用量增加。</p></li><li><p><strong>缺乏压缩支持：</strong> HTTP/1.0没有内置的数据压缩机制，因此在传输大量文本数据时，没有有效地压缩数据，增加了网络传输的开销。</p></li><li><p><strong>安全性问题：</strong> HTTP/1.0没有提供任何加密和安全机制，所有的数据都是明文传输。这使得数据容易受到窃听和篡改，缺乏对隐私和数据完整性的保护。</p></li><li><p><strong>实现混乱：</strong> 由于HTTP/1.0并不是官方标准，许多浏览器厂商并没有按照HTTP/1.0的指导实现HTTP，导致在实际运用中混乱不堪。</p></li></ul><p>可以看到对于HTTP/0.9人们诟病的是它的文件类型支持不够丰富，由于它的文件类型支持不丰富，所有通常只是请求HTML文档，往往发送一次请求就能获取到完整的内容。而在HTTP/1.0丰富了文件类型后，一次请求不再能获取到全部内容，并且请求的内容也从较小的HTML文档发展到了图片、音频、视频等较大的文件，此时HTTP的性能问题也被暴露出来。</p><p>此外，由于各个浏览器相互竞争，各自为战，并且HTTP/1.0并不是官方标准，只是一些指导意见。这导致各个厂商对于HTTP都有各自的实现方式，导致在实际运用中混乱不堪。</p><p>由于上述原因，人们迫切需要优化HTTP性能，制定一份标准化HTTP协议！</p><details class="details custom-block"><summary>🎈本节参考</summary><ul><li><p><a href="https://webfoundation.org/about/vision/history-of-the-web/" target="_blank" rel="noreferrer">https://webfoundation.org/about/vision/history-of-the-web/</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noreferrer">https://zh.wikipedia.org/wiki/超文本传输协议</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP</a></p></li><li><p>《图解HTTP》</p></li><li><p><a href="https://hpbn.co/brief-history-of-http/" target="_blank" rel="noreferrer">https://hpbn.co/brief-history-of-http/</a></p></li></ul></details><p>转载需要经过本人同意！</p>`,34);function C(g,d,P,H,y,E){const a=e("P");return t(),o("div",null,[T,l(a,{align:"center",style:{color:"gray"}},{default:p(()=>[r("蒂姆最初的提议。图片来源：欧洲核子研究中心")]),_:1}),h])}const A=n(c,[["render",C]]);export{u as __pageData,A as default};
